---
title: V2ray 搭建与配置记录 (一)
date: 2023-05-22 12:34:43
tags:
- VPS
- v2ray
categories:
- v2ray
---

## 前言
近来想纯净自己的ip，同时也想试着搭建 v2ray 服务供以自己代理使用，所以上两个星期便购买了一台 Vultr 的 VPS。出现了一些问题，同时也确实都得以解决了，想着这里简单记录一下配置的过程，以便下次继续搭建。

这是第一次尝试使用 vps 搭建 v2ray 服务，事实上非常的顺利，我确实完成了 v2ray 的搭建，但是第三天便遭到了中国政府的防火墙一记 ban ip 操作。现在想着这是极为危险的，但事情还得继续，问题自然是发生在我未对 v2ray 进行伪装，因为初次接触，所以对很多新的名词有恐惧心理，一开始便没有去尝试伪装操作，最终酿下错误，但是错误的本身其实也在推动着我技术的进步。

问题的解决方法是，首先通过 WebSocket+TLS+Web 完成对传输层流量伪装，原理就是通过 Nginx 搭建了一个真实的网站，分流一个特定的路由去转发 v2ray 的流量，其实正常的伪装到这里就结束了。但前面我说了，我的 VPS ip 被封杀了，其导致了我没办法在国内正常通过 ssh 访问到服务器，所以根据攻略我又加了一层伪装，我将我的域名名服务器交给 cloudflare 让其帮我把域名伪装成其他的ip，从而躲过封杀。

目前时间是 2023年5月，之前的文章都没有强调要一定套上 TLS 伪装才能使用，但事实上，随着时间的发展，直接使用 v2ray 已经能被精确发现，套一上 TLS ，加密 HTTP 是很有必要的。

## 配置 vps 和 v2ray
请注意，在接下来的所有操作中，我均使用 root 账户执行操作。

### 安装 git

```
apt-get install git
```

### 安装 zsh 和 ohmyzsh
Linux 自带的 bash 不是那么方便使用，所以换成 zsh 是个更好的选择。

```
apt-get install zsh
sh -c "$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)"
```

### 安装 v2ray

#### 通过官方脚本自动安装 v2ray 本体
确实有很多种方式安装 v2ray，我这里选择使用 `fhs-install-v2ray` 项目提供的安装脚本进行安装：
主要是它能帮我自动创建一些文件：
```
installed: /usr/local/bin/v2ray
installed: /usr/local/bin/v2ctl
installed: /usr/local/share/v2ray/geoip.dat
installed: /usr/local/share/v2ray/geosite.dat
installed: /usr/local/etc/v2ray/config.json
installed: /var/log/v2ray/
installed: /var/log/v2ray/access.log
installed: /var/log/v2ray/error.log
installed: /etc/systemd/system/v2ray.service
installed: /etc/systemd/system/v2ray@.service
```

执行下面的程序脚本即可（目前时间是：2023-05-22，该脚本未来可能发生变动，以具体情况为准）
此处贴出项目 README 文件：[README.zh](https://github.com/v2fly/fhs-install-v2ray/blob/master/README.zh-Hans-CN.md)

```
bash <(curl -L https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh)
```

执行完后，若无明显错误，即可通过 `systemctl start v2ray.service` 和 `systemctl status v2ray.service` 查看是否能正确启动。

#### 配置 v2ray 服务端 
无论是服务端亦或是客户端的配置，其实都非常简单，只需要将配置文件改动一些即可使用。
以下是官方提供的服务端配置：
```json
{
    "inbounds": [
        {
            "port": 11223, // 服务器监听端口
            "protocol": "vmess",
            "settings": {
                "clients": [
                    {
                        "id": "xxxxxxxxxxxxxxx",
                        "alterId": 0
                    }
                ]
            }
        }
    ],
    "outbounds": [
        {
            "protocol": "freedom"
        }
    ]
}
```
在入门阶段，只需要了解 `inbounds` 中的 `port` 和 `id` 即可。
- `port` 即是服务器的监听端口
- `id` 可以理解为某种密钥一样的存在，在服务端与客户端交流时，需要通过这值进行辨别身份。可以使用 `cat /proc/sys/kernel/random/uuid` 指令生成这个 id。

> 服务器的配置中需要确保 id 和端口与客户端一致，就可以正常连接了。

最后重启一下 v2ray 服务即可：`systemctl restart v2ray.service` ，当然因为可能存在的将配置文件写错的问题，最好再查看一下有没有错误产生 `systemctl status v2ray.service`

没有问题后，即可开始配置 v2ray 客户端。

啊，最后注意让防火墙放开对应的端口，比如这里的11223端口，若是不开放是万万无法连接的
```
ufw allow 11223/tcp
```
### 配置 v2ray 客户端
- Linux 平台可以使用 v2ray 程序(服务器所用的那个)，它即可以当服务端也可以作为客户端使用
- Android 平台可以使用 v2rayNG 
- Windows 平台可以使用 v2rayN

无论是 android 还是 windows，其都有相应的图形界面，配置起来很简单，这里主要讲一下 Linux 的 v2ray 如何作为客户端使用。

v2ray 既可以作为服务端也可以作为客户端，只不过是配置不同而已。

以下贴出官方提供的客户端配置：

```json
{
  "inbounds": [
    {
      "port": 1080, // 监听端口
      "protocol": "socks", // 入口协议为 SOCKS 5
      "sniffing": {
        "enabled": true,
        "destOverride": ["http", "tls"]
      },
      "settings": {
        "auth": "noauth"  //socks的认证设置，noauth 代表不认证，由于 socks 通常在客户端使用，所以这里不认证
      }
    }
  ],
  "outbounds": [
    {
      "protocol": "vmess", // 出口协议
      "settings": {
        "vnext": [
          {
            "address": "serveraddr.com", // 服务器地址，请修改为你自己的服务器 IP 或域名
            "port": 16823,  // 服务器端口
            "users": [
              {
                "id": "xxxxxx",  // 用户 ID，必须与服务器端配置相同
                "alterId": 0 // 此处的值也应当与服务器相同
              }
            ]
          }
        ]
      }
    }
  ]
}
```
虽然这看起来蛮多的，但需要修改的地方也就是 `outbounds` 里的 `address`、`port` 和 `id`
- `address` 填入 vps 的 ip 地址亦或是域名
- `port` 填入服务端中监听的那个地址
- `id` 填入服务端设定的 id

这样一切弄完后，在配置一下 `socks_proxy` 的环境变量即可。
```
export socks_proxy=https://127.0.0.1:1080;"
```
当然也可以把 `http_proxy` 和 `https_proxy` 代理填入。

若是你想在浏览器使用：
- firefox 相对方便，直接在设置中选择 socks5 代理，地址即填入配置文件中的：`127.0.0.1:1080`
- chrome 可以去下载 名为 `SwitchyOmega` 的插件，也使用 sock5 配置即可

好啦，到目前为止，服务端和客户端都已经配置完成。

### TLS 加密前言
接下来有一些太长的内容，若是你不感兴趣，则可以跳过。

此处先给出参考的文章引用，在文章末尾也会重复给出，感谢各位前辈的教程。
- [V2Fly](https://www.v2fly.org/guide/install.html)
- [V2Ray+WebSocket+TLS+Web+Cloudflare教程](https://whuwangyong.vercel.app/2023-03-18-v2ray-websocket-tls-web-cloudflare-guide/)
- [linuxfunk](https://linuxfunk.com/2017/10/31/v2ray-ws-tls-nginx%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93/)
- [V2Ray进阶指南：WSS组合配置(WebSocket + TLS + Nginx + CDN)](https://cyfeng.science/2020/03/22/advanced-v2ray-with-wss/)

在完成了之前那些操作后，自然是可以正常使用 v2ray 的，但是非常容易被封杀(我的坚持了两天hhhhh)，这也是我后来才得知道的 :(

总之，被封杀了我便意识到了伪装是极其重要的，以下先介绍一些概念名称，我刚开始接触这一部分便直接放弃了，但遗憾的是这一部分却又不得不学，我们只能被迫去与之对抗。


#### TLS
`TLS 加密`，TLS 中文叫 传输层安全性协议，以下是 wikipedia 的描述：
> 将通信两方交换的资料做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听

这是用来加密的，广为人知的 `HTTP` 在经过 TLS 加密后，成为了`HTTPS`

若是 v2ray 的流量没有被 TLS 加密，那么审查者便能根据数据内容分析出，这是违“法”的数据，而且代理流量源源不断地从固定 ip 发来，这样的流量同样是不正常的。

#### 网站前置伪装 与 websocket 协议
仅用 TLS 加密依旧是不够的，因为流量不正常，这些大规模的流量因为代理的原因来去于同一个ip，这样的流量即使是加密的，也应该是有问题的。所以，需要再完成一次伪装，使用 Nginx 与 域名 搭建一个真实的网站，我们的客户端通过 websocket（ws）协议与这个用 Nginx 作为前端的网站进行数据交流，这样一来，我们的服务器就是正儿八经的网站服务器（事实也确实如此），而非代理服务器，在找到某种特征之前，不可能大面积封杀这样的正常服务器。

使用，我们现在的任务很简单，购买一个域名（可以是免费的二级域名），在我们的 VPS 中通过 Nginx 搭建一个真实但简单的网站，然后让客户端和服务器端通过ws协议交流，接着通过 Nginx 分流特定的路由。



## V2Ray + TLS + Websocket 
**若是你需要使用 TLS 加密你的流量，则你必须拥有一个域名！**

**本文 使用 domain.com  作为演示。**

### 域名购买

1. namesilo 购买
2. eu.org 申请二级域名

这里完全不推荐在国内购买相关域名，备案审查总归是非常麻烦且不安全。我的域名都是在 namesilo 进行购买，它支持使用支付宝，在国内来说是相对方便的，购买后可以选择使用cloudflare 的 cdn，若是选择了cloudflare 托管名服务器，在国内而已速度是会降低很多的（但是可以接受）。

而接下来介绍的第二种方法则完全依靠于 cloudflare 的 tls ，完成 https 的证书一键生成，可以免去大量地繁琐操作。

若是你不希望花费金钱，你可以从 **EU.org** 申请一个二级域名，之后将这个二级域名交付 cloudflare 管理，同样能完成 TLS 加密。

在购买了域名之后，使用 A 记录指向服务器 ip 即可。

### 起步之前的话
在之前的操作中，我们在服务器中使用 v2ray 监听了 11223 端口，同时开放了防火墙，但若你要进行接下来的操作，记得之后关闭这个端口，因为最终我们会使用 nginx 对流量进行分流，也就是反向代理，便不需要这个端口了。

### 方法一
首先说明，这是一个比较费时费力的方法，需要一些 Linux 和 Web 的相关知识，但这是相对普遍的方法。

其过程如下：

- 部署一个页面或者网站，即使很简单也没有问题
- 给网站安装 tls 证书
- 使用 Nginx 完成反向代理

#### 部署一个页面或者网站
##### 建立站点根目录
我们在 `/var/www` 新建一个目录：

``` 
$ mkdir domain.com 
$ cd domain.com
$ vim index.html
```
对于 `index.html` 随便写些内容就好，比如：
```
 <h1> Hello World </h1>
```

##### 修改 nginx virtual host
```
$ cd /etc/nginx/sites-enabled
$ vim domain.com
```

内容如下：
```
server {
    listen 80; # 监听80端口
    server_name domain.com; # 你的域名

    root /var/www/domain.com; # 网站根目录
    index index.html; # 主页

    # 路由
    location / {
        try_files $uri $uri/ =404;
	}
}
```

修改完后，将其作为默认的配置：
```
$ ln -s domain.com default
```

#### 给网站安装 TLS 证书
我主要是根据[这篇文章](https://guide.v2fly.org/advanced/tls.html#%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D)完成的，建议您在操作的时作为参考使用。

##### 安装 acme.sh
通过 acme.sh 脚本帮助我们完成 TLS 证书认证。
> 证书有两种，一种是 ECC 证书（内置公钥是 ECDSA 公钥），一种是 RSA 证书（内置 RSA 公钥）。简单来说，同等长度 ECC 比 RSA 更安全,也就是说在具有同样安全性的情况下，ECC 的密钥长度比 RSA 短得多（加密解密会更快）。但问题是 ECC 的兼容性会差一些，Android 4.x 以下和 Windows XP 不支持。只要您的设备不是非常老的老古董，建议使用 ECC 证书。
>
> 来源于：[v2fly](https://guide.v2fly.org/advanced/tls.html#%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D)



执行下面的命令，会在当前目录中创建 .acme 文件夹：

```
$ curl  https://get.acme.sh | sh
```

若是出现缺少依赖，按照其给出的包名，使用`apt install xxxx `进行安装即可。

##### 证书生成 

```
$ ~/.acme.sh/acme.sh --issue -d domain.com --standalone --keylength ec-256 --force
```

当然，第一次执行可能会报错，因为它需要填写电子邮箱：

```
$ ~/.acme.sh/acme.sh --register-account -m xxxx@xxxx.com
```

填写完邮箱后，再重新执行第一条指令即可。	

成功后，会打印出相关证书，在末尾则会出现，类似的内容：

```
Your cert is in  /root/.acme.sh/domain.com_ecc/mydomain.me.cer
Your cert key is in  /root/.acme.sh/domain.com_ecc/mydomain.me.key
The intermediate CA cert is in  /root/.acme.sh/domain.com_ecc/ca.cer
And the full chain certs is there:  /root/.acme.sh/domain.com_ecc/fullchain.cer
```



> 注意, 默认生成的证书都放在安装目录下: `~/.acme.sh/`, 请不要直接使用此目录下的文件, 例如: 不要直接让 nginx/apache 的配置文件使用这下面的文件. 这里面的文件都是内部使用, 而且目录结构可能会变化.
>
> 来源： [acmesh](https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E)



以下是 acme.sh README 给出的示例，使用` --install-cert`参数将证书安装到指定的位置：

```
acme.sh --install-cert -d example.com \
--key-file       /path/to/keyfile/in/nginx/key.pem  \
--fullchain-file /path/to/fullchain/nginx/cert.pem \
--reloadcmd     "service nginx force-reload"
```

例如：

```
$ ~/.acme.sh/acme.sh --install-cert -d domian.com \
	--key-file /etc/ssl/key.key	\
	--fullchain-file /etc/ssl/cert.crt                     
```



接下来继续配置 Nginx ，给 Nginx 安装证书，这里我手动填写了一些配置，我会一步一步完成，请耐心看下去：

首先，您必须得知道 HTTP 默认在 80 端口，而 HTTPS 默认在 443 端口，也就是当用户在浏览器访问类似链接时：http://domain.com,其默认从 80 端口访问的HTTP服务，这是不安全的，所以我们需要返回 301 状态码，让浏览器跳转到加密的 HTTPS 服务上来，通过 tls 加密后的链接是这样的：https://domain.com。

我们接下来完成的就是将访问 80 端口的流量重定位到 443端口去。

当然，你也可以直接跳到最后。

若是你一步步跟随我，你的 nginx 的配置文件应该是这样的：

```
server {
    listen 80; # 监听80端口
    server_name domain.com; # 你的域名

    root /var/www/domain.com; # 网站根目录
    index index.html; # 主页

    # 路由
    location / {
        try_files $uri $uri/ =404;
	}
}
```

我们对其进行一些修改，依旧是监听 80 端口，这是 HTTP 协议默认端口，但是这是不安全的，我们之前已经配置了 TLS，接下来需要做的技术凡是从80进入的流量全部转发至 433 端口，这是加密的 HTTPS 默认的端口。

也就是，当用户浏览器从 http://mydomain.com 进入时，将其跳转至 https://mydomain.com.

```
server {
	listen 80; # 监听80端口，将所有访问 80 端口的流量，全部重定位到 https 
	server_name domain.com;

	# 301 重定位
	if ($host = mydomain.com) {
		return 301 https://$host$request_uri;
 	}
	# 否则返回 404 
	return 404; 
}
```

接着，我们具体配置一下 来自 443 端口的流量，在上一步后，所有使用 http 协议的请求均会被重定位到 443 端口。

下面的文件添加了新的 server , 它将监听443端口，同时我们部署了证书文件通过 `ssl_certificate` 和 `ssl_certificate_key `

```
server {
	listen 443 ssl; # 监听443端口
	server_name domain.com;
	root /var/www/mydomain.com;
 	index index.html;

	ssl_certificate       /etc/ssl/cert.crt;
	ssl_certificate_key   /etc/ssl/key.key;
	ssl_session_timeout 1d;
	ssl_session_cache shared:MozSSL:10m;
	ssl_session_tickets off;
	ssl_protocols         TLSv1.2 TLSv1.3;

 	location / {
		try_files $uri $uri/ =404;
	}


}

server {
	listen 80; # 监听80端口，将所有访问 80 端口的流量，全部重定位到 https 
	server_name domain.com;

	# 301 重定位
	if ($host = mydomain.com) {
		return 301 https://$host$request_uri;
 	}
	# 否则返回 404 
	return 404; 
}
```

在份文件中，我新增了：

```
server {
	listen 443 ssl; # 监听443端口
	server_name domain.com;
	root /var/www/mydomain.com;
 	index index.html;

	ssl_certificate       /etc/ssl/cert.crt;
	ssl_certificate_key   /etc/ssl/key.key;
	ssl_session_timeout 1d;
	ssl_session_cache shared:MozSSL:10m;
	ssl_session_tickets off;
	ssl_protocols         TLSv1.2 TLSv1.3;

 	location / {
		try_files $uri $uri/ =404;
	}


}
```



上面这一步，则是在处理 443 端口发来的请求的路由情况，我们任然是当其 进入`/` 后，返回当前网站的根目录。

接着，我们来处理 V2ray 的流量，我们设定一个路由 `/proxy`，凡是进入该路由的，均将流量反向代理至 v2ray 监听的端口，之前设置的是 11223。

```
server {
	listen 443 ssl; # 监听443端口
	server_name domain.com;
	root /var/www/mydomain.com;
 	index index.html;

	ssl_certificate       /etc/ssl/cert.crt;
	ssl_certificate_key   /etc/ssl/key.key;
	ssl_session_timeout 1d;
	ssl_session_cache shared:MozSSL:10m;
	ssl_session_tickets off;
	ssl_protocols         TLSv1.2 TLSv1.3;

 	location / {
		try_files $uri $uri/ =404;
	}
	
	location /proxy { 
	# WebSocket协商失败时返回404
    if ($http_upgrade != "websocket") { 
        return 404;
    }
    proxy_redirect off;
    proxy_pass http://127.0.0.1:11223; # 转发至 11223 端口，v2ray监听处
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    # Show real IP in v2ray access.log
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }


}

server {
	listen 80; # 监听80端口，将所有访问 80 端口的流量，全部重定位到 https 
	server_name domain.com;

	# 301 重定位
	if ($host = mydomain.com) {
		return 301 https://$host$request_uri;
 	}
	# 否则返回 404 
	return 404; 
}
```

可以看到，这份文件中，我新增了:

```
location /proxy { 
	# WebSocket协商失败时返回404
    if ($http_upgrade != "websocket") { 
        return 404;
    }
    proxy_redirect off;
    proxy_pass http://127.0.0.1:11223; # 转发至 11223 端口，v2ray监听处
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    # Show real IP in v2ray access.log
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }
```

它将 从 /proxy 路由进入的流量反向代理至 11223 端口

那么，Nginx 的配置就完成啦！！！

上面这份就是最终的配置文件。

#### V2ray 服务端配置

***原先：***

```
{
    "inbounds": [
        {
            "port": 11223, // 服务器监听端口
            "protocol": "vmess",
            "settings": {
                "clients": [
                    {
                        "id": "xxxxxxxxxxxxxxx",
                        "alterId": 0
                    }
                ]
            }
        }
    ],
    "outbounds": [
        {
            "protocol": "freedom"
        }
    ]
}
```

在 `inbounds`添加`streamSettings`设置：

```
{
    "inbounds": [
        {
            "port": 11223,
            "listen": "127.0.0.1",
            "protocol": "vmess",
            "settings": {
                "clients": [
                    {
                        "id": "xxxxxx",
                        "alterId": 0
                    }
                ]
            },
            "streamSettings": {
                "network": "ws",
                "wsSettings": {
                    "path": "/proxy"
                }
            }
        }
    ],
    "outbounds": [
        {
            "protocol": "freedom",
            "settings": {}
        }
    ]
}
```

恭喜你，在你完成这一步，在服务端所要干的事情就完成了！



#### V2ray 客户端配置

客户端就没啥好说的了，就是基本配置一下即可。

主要修改的地方就是 `outbounds` 的 `address` 和 `streamSettings`

```
{
  "inbounds": [
    {
      "port": 1080, 
      "protocol": "socks", 
      "sniffing": {
        "enabled": true,
        "destOverride": ["http", "tls"]
      },
      "settings": {
        "auth": "noauth" 
      }
    }
  ],
  "outbounds": [
    {
      "tag":"default",
      "protocol": "vmess", 
      "settings": {
        "vnext": [
          {
            "address": "domain.com", 
            "port": 443,  
            "users": [
              {
                "id": "xxxxx", 
                "alterId": 0 
              }
            ]
          }
        ]
      },
      "streamSettings":{
      	"network": "ws",
		"security": "tls",
		"wsSettings": {
	  		"path":"/proxy"
		}
      }
    }
  ]
}
```



## 最后及参考

只有果壳中走出，才知道自由是何物。

- [V2Fly](https://www.v2fly.org/guide/install.html)
- [V2Ray+WebSocket+TLS+Web+Cloudflare教程](https://whuwangyong.vercel.app/2023-03-18-v2ray-websocket-tls-web-cloudflare-guide/)
- [linuxfunk](https://linuxfunk.com/2017/10/31/v2ray-ws-tls-nginx%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93/)
- [V2Ray进阶指南：WSS组合配置(WebSocket + TLS + Nginx + CDN)](https://cyfeng.science/2020/03/22/advanced-v2ray-with-wss/)
