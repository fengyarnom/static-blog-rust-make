<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/static/css/style.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%2210 0 100 100%22><text y=%22.90em%22 font-size=%2290%22>🐱</text></svg>">
    <title>Yarnom'Blog</title>
</head>
<body>
    <header>
    <div class="nav_area">
        <div class="logo">
            <a href="/">Yarnom</a>
            <div class="menu_mobile" onclick="toggleMenu()">
                <span class="menu_icon">&#9776;</span> <!-- Unicode hamburger icon -->
            </div>
        </div>
        
        <div class="nav_bar">
            <ul>
                
                <li><a href="/archive">归档</a></li>
                <li><a href="/categories">分类</a></li>
                <li><a href="/tags">标签</a></li>
                <li><a href="https://memos.yarnom.top">碎碎念</a></li>
                <li><a href="/link">友链</a></li>
                <li><a href="/about">关于</a></li>
            </ul>
        </div>
    </div>
</header>
<script>
    function toggleMenu() {
    var menu = document.querySelector('.nav_bar');
        menu.classList.toggle('show_nav_bar');
    }
</script>
    
    <div class="main_container">
        <div class="main_content main_area">
            
    
    
        <div class="articles">
            <div class="post">
                <div class="header_post">
                    <div class="title_post"><a href="&#x2F;posts&#x2F;我的静态博客生成器-2023-08-27 09:22:56.html">我的静态博客生成器</a></div>
                    <div class="detail_post">
                        <div class="date">发布时间：2023-08-27 09:22:56</div>
                        <div class="categories">
                            归档分类：
                            <ul>
                                
                                <li><a href="/categories/项目">项目</a></li>
                                
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="content_post"><p>近些日子无心向学，于是又手痒折腾起了代码。</p>
<p>起因是接触到了 Rust 这门语言，并了解到了它的很多特性。我认为这真的是一个很棒的语言并且惊叹于它的性能。正因如此，我决定以此为契机，开始了一个新的项目，一个使用 Rust 编写的静态博客生成器。</p>
<h2>项目情况</h2>
<p>目前它只是一个堪堪能用的状态，我甚至还没想好它的名字，现在只是使用 <code>static-blog-rust-make</code> 作为项目名字，我并没有想出一个正式的名字。我目前开源在<a href="https://github.com/fengyarnom/static-blog-rust-make">Github</a> 上，由于时间实在是不够用，我在有限的时间内已经做到了极限，优化代码和新功能的添加只能在日后完成了，但是，我仍然十分满意于这个项目！</p>
<p>虽然如此，这个生成器确实已经可以正常使用。我用它来重新生成了一个这个网站，并将之前为 Hexo 写的主题应用其中。目前的版本是 <em><strong>v0.03</strong></em> 。项目仅仅是一个粗劣地模仿 Hexo 的产物，并没有融入很多我的思考，很多核心功能也只是调用别人写好的包，但是这次的代码仍然给我很多地启示，我发觉我开始接触到了很多软件工程的内容，同时对一个项目的整体规划有了一些了解。总之，这一次的项目开发还是很有意思的，之后的一段时间会着手于新的开发文档，并希望能在书写开发文档的过程中，思考更多新的功能。</p>
<p>最后，这是一个非常不完美的项目，里面的代码混乱不堪，复杂的逻辑结构几乎把我压倒。在多次重构和清理冗杂代码后，确实完成了我一开始定下的所有功能需求，但是这样的代码总归让人看了倒胃口，但也只能在之后的日子里慢慢修改完善啦，至少它没有夭折在漫长的开发期中。我确实是以最快的速度开发的，为的就是减少枯燥，目前看来确实如此，我在耐心消耗殆尽前完成了这个项目。</p>
</div>
                <div class="tags_post"></div>
            </div>
        </div>
    
        <div class="articles">
            <div class="post">
                <div class="header_post">
                    <div class="title_post"><a href="&#x2F;posts&#x2F;你好，OrangePi Zero3！🍊-2023-08-17 11:48:44.html">你好，OrangePi Zero3！🍊</a></div>
                    <div class="detail_post">
                        <div class="date">发布时间：2023-08-17 11:48:44</div>
                        <div class="categories">
                            归档分类：
                            <ul>
                                
                                <li><a href="/categories/开箱">开箱</a></li>
                                
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="content_post"><p>本篇文章将详细地写下我配置这块单板计算机的全过程，之后若是有新的自托管服务也会在本文记录下来。</p>
<h2>购买</h2>
<p>自从接触 Linux 之后渴望得到一个树莓派了，奈何因为疫情导致了全球的芯片供应紧张，树莓派的价格水涨船高，价格已经远远超过了它的价值，更重要的是超过了我的预算，即使是二手的价格也非常不值当。总之，出于囊中羞涩的考虑，我最终选择了这块国产的派 —— <strong>OrangePi Zero3.</strong></p>
<p><img src="https://s2.loli.net/2023/08/27/uq5Lpt4VhGs3eTZ.png" alt="2023-08-17_12-27.png" /></p>
<p>我购买的是内存为 1.5G 的版本价格为一百出头，刚拿到快递的时候我就疑惑了， 为何如此之小！开箱后更是震惊，它甚至没有我的巴掌大呢！虽然但是，这还是很精致的，而且对于这样的设备而言，小其实是更好的，更方便搭载在其他的设备上。</p>
<p><img src="https://s2.loli.net/2023/08/27/ZeyCJqUun7NYE2I.jpg" alt="photo_6264513425795298480_y.jpg" /></p>
<p>除开这块板子，我还另外买了：</p>
<ul>
<li>亚克力的外壳</li>
<li>风扇+散热片</li>
<li>USB to TTL 用于串口调试</li>
<li>64G 闪迪 tf 卡</li>
</ul>
<p>关于系统镜像方面，我还是选择了熟悉的 debian 发行版，毕竟我的 vps 用的也是这个，这块单板计算机我是拿来内网穿透的 <a href="http://www.orangepi.cn/html/hardWare/computerAndMicrocontrollers/service-and-support/Orange-Pi-Zero-3.html">官方镜像</a></p>
<p><img src="https://s2.loli.net/2023/08/27/2gtelYJwAKvsV8X.png" alt="2023-08-17_12-42.png" /></p>
<h2>系统配置</h2>
<p>在向 tf 卡刷完系统后，就可以通过串口进行连接了。</p>
<h3>自动连接热点 WiFi</h3>
<p>使用串口多少是不方便的，所以先来配置一下网络，让其他机器可以通过 ssh 访问这块板子。</p>
<ol>
<li>
<p>使用<code>nmcli dev wifi</code>查看当前扫描到的 wifi 列表。</p>
</li>
<li>
<p>使用 <code>nmcli</code> 连接到热点并输入密码：</p>
</li>
</ol>
<pre><code class="language-bash">sudo nmcli dev wifi connect YourHotspotName password YourPassword
</code></pre>
<ol start="3">
<li>将连接的配置设置为自动连接：</li>
</ol>
<pre><code class="language-bash">sudo nmcli connection modify &quot;YourHotspotName&quot; connection.autoconnect yes
</code></pre>
<p>将 <code>YourHotspotName</code> 替换为你的热点名称，<code>YourPassword</code> 替换为密码。</p>
<p>完成后通过 <code>ip addr </code> 即可看到 ip 地址，然后就可以通过 ssh 正常访问板子了</p>
<h3>添加一个新用户</h3>
<pre><code>useradd -m -G additional_groups -s login_shell username
</code></pre>
<pre><code class="language-bash">passwd username
</code></pre>
<p>然后去修改<code> /etc/sudoers</code> 文件</p>
<h2>FRP 内网穿透</h2>
<p>在这个 <a href="https://github.com/fatedier/frp/releases">releases</a> 页面中，找到对应架构的压缩包，可以使用 <code>uname -a </code> 查看到。</p>
<ul>
<li>我的 VPS 是 X86_64 那么就选择 <a href="https://github.com/fatedier/frp/releases/download/v0.51.3/frp_0.51.3_linux_amd64.tar.gz">amd64.tar.gz</a> 的包</li>
<li>香橙派是 arm 架构，那么就选择 <a href="https://github.com/fatedier/frp/releases/download/v0.51.3/frp_0.51.3_linux_arm64.tar.gz">arm64.tar.gz </a>的包</li>
</ul>
<p>通过 <code>wget</code> 下载</p>
<pre><code class="language-bash">wget https://github.com/fatedier/frp/releases/download/v0.51.3/frp_0.51.3_linux_arm64.tar.gz
</code></pre>
<p>通过 <code>tar</code> 解压</p>
<pre><code class="language-bash">tar xvf frp_0.51.3_linux_arm64.tar.gz
</code></pre>
<ul>
<li><strong>frpc</strong>: 这是 FRP 客户端的可执行文件。FRP 客户端用于连接到 FRP 服务器并将内部网络服务暴露给外部访问。</li>
<li><strong>frps</strong>: 这是 FRP 服务器的可执行文件。FRP 服务器用于接收来自客户端的连接，并将这些连接转发到内部的网络服务。</li>
<li><strong>frpc.ini</strong>: 这是 FRP 客户端的配置文件，用于指定客户端的连接设置、代理规则等。</li>
<li><strong>frps.ini</strong>: 这是 FRP 服务器的配置文件，用于指定服务器的监听端口、代理规则等。</li>
<li><strong>frpc_full.ini</strong>: 这是 FRP 客户端的完整配置文件，可能包含更多详细的设置。</li>
<li><strong>frps_full.ini</strong>: 这是 FRP 服务器的完整配置文件，可能包含更多详细的设置。</li>
</ul>
<h3>服务器配置</h3>
<p>下载完对应架构的文件后，即可开始配置，只需要关心 <code>frps</code> 和 <code>frps.ini</code> 文件即可，前者是FRP 服务器的可执行文件，后者是这是 FRP 服务器的配置文件。</p>
<p>打开 <code>frps.ini</code>进行配置，配置文件的内容如下：</p>
<pre><code class="language-ini">[common]
bind_port = 7000
token = 1234567890
</code></pre>
<p>客户端和服务器的配置文件中都需要设置相同的 Token 才能正确进行连接和通信。</p>
<p>为了保障安全性，你应该选择一个强密码的 Token，并确保不会轻易泄露给他人。如果你怀疑 Token 可能已经暴露，应当立即生成一个新的 Token 并更新配置文件。</p>
<p>完成后，运行 <code>./frpc -c ./frpc.ini</code></p>
<p>若无问题，则说明配置成功。</p>
<p>接下来，配置一下 systemd 服务，让上面这条运行命令能开机自动启动，这非常实用：</p>
<p>但是在此之前，我们需要先将 <code>frps</code> 和 <code>frps.ini</code> 文件放到合适的地方：</p>
<pre><code>sudo cp frps /usr/local/bin/
sudo mkdir /usr/local/etc/frp
sudo cp frps.ini /usr/local/etc/frp/
</code></pre>
<p>首先，创建一个名为<code>frps.service</code>的文件，该文件将存储有关你的自启动服务的信息。通常，这些文件存放在<code>/etc/systemd/system/</code>目录下。</p>
<pre><code class="language-bash">sudo vim /etc/systemd/system/frps.service
</code></pre>
<pre><code>[Unit]
Description=frps
After=network.target
[Service]
TimeoutStartSec=30
WorkingDirectory=/usr/local/bin/
ExecStart=/usr/local/bin/frps -c /usr/local/etc/frp/frps.ini
Restart=on-failure
[Install]
WantedBy=multi-user.target
</code></pre>
<p>保存后，执行：</p>
<pre><code>sudo systemctl enable frps
sudo systemctl start frps
sudo systemctl status frps
</code></pre>
<p>若无问题，则可进入客户端的配置。</p>
<p>下面是一些常用的命令：</p>
<ul>
<li>启动服务：<code>sudo systemctl start frps</code></li>
<li>停止服务：<code>sudo systemctl stop frps</code></li>
<li>重启服务：<code>sudo systemctl restart frps</code></li>
<li>查看服务状态：<code>sudo systemctl status frps</code></li>
<li>关闭自启动：<code>sudo systemctl disable frps</code></li>
</ul>
<h3>客户端配置</h3>
<p>下载完对应架构的文件后，即可开始配置，只需要关心 <code>frpc</code> 和 <code>frpc.ini</code> 文件即可，前者是FRP 客户端的可执行文件，后者是这是 FRP 客户端的配置文件。</p>
<p><strong>假设：</strong></p>
<p><strong>服务器的ip地址是 1.1.1.1, 服务端frp正在监听的端口是7000, token是1234567890</strong></p>
<p><strong>客户端目前正在运行一个项目叫 bitwarden ,它正在本地 0.0.0.0 地址上监听 1111 端口</strong></p>
<p>打开 <code>frpc.ini</code>进行配置，配置文件的内容如下：</p>
<pre><code>[common]
server_addr = 1.1.1.1
server_port = 7000
token = 1234567890

[bitwarden]
type = tcp
local_ip = 0.0.0.0
local_port = 1111
remote_port = 8111
</code></pre>
<p>值得注意的是，配置文件中的 [bitwarden] 可以替换成任何想要的名字</p>
<p>为了方便，我们同样设置 systemd 服务</p>
<p>但是在此之前，我们需要先将 <code>frpc</code> 和 <code>frpc.ini</code> 文件放到合适的地方：</p>
<pre><code>sudo cp frpc /usr/local/bin/
sudo mkdir /usr/local/etc/frp
sudo cp frpc.ini /usr/local/etc/frp/
</code></pre>
<p>首先，创建一个名为<code>frpc.service</code>的文件，该文件将存储有关你的自启动服务的信息。通常，这些文件存放在<code>/etc/systemd/system/</code>目录下。</p>
<pre><code class="language-bash">sudo vim /etc/systemd/system/frpc.service
</code></pre>
<pre><code>[Unit]
Description=frpc
After=network.target
[Service]
TimeoutStartSec=30
WorkingDirectory=/usr/local/bin/
ExecStart=/usr/local/bin/frpc -c /usr/local/etc/frp/frpc.ini
Restart=on-failure
[Install]
WantedBy=multi-user.target
</code></pre>
<p>保存后，执行：</p>
<pre><code>sudo systemctl enable frpc
sudo systemctl start frpc
sudo systemctl status frpc
</code></pre>
<p>若无问题的话，则说明没有问题！</p>
<h3>原理</h3>
<p>Frp（Fast Reverse Proxy）是一个用于内网穿透的工具，它允许你在公网上访问位于内网的计算机服务。它的原理是通过在公网服务器上部署 frps（Frp 服务器端）和在内网机器上部署 frpc（Frp 客户端），通过公网服务器作为中转，将外部请求转发到内网机器上。</p>
<ul>
<li>在公网服务器上部署 frps：公网服务器上运行的 frps 监听一个指定的端口，等待来自 frpc 的连接。</li>
<li>在内网机器上部署 frpc：内网机器上的 frpc 将建立到 frps 的连接，并注册自己的服务信息。frpc 和 frps 之间建立的连接可以被用于穿透数据。</li>
<li>数据传输：当公网客户端请求连接到公网服务器的指定端口时，frps 会将这个请求转发给已经连接的 frpc 客户端，然后 frpc 客户端再将请求转发到内网机器的指定服务上。</li>
</ul>
<p>在我上面的配置中，其转换的意思就是：</p>
<p>frps 监听在公网服务器的 7000 端口，frpc 连接到公网服务器的 7000 端口，并注册自己的服务信息。frpc 客户端配置了一个类型为 TCP 的服务，将本地的 bitwarden 服务映射到公网服务器的 8111 端口上。</p>
<p>若是请求 https://1.1.1.1:8111 那么这个请求就转发给客户端的 http://0.0.0.0:1111</p>
<h3>Nginx 配置</h3>
<p>我在服务器中是使用 Nginx 来进行反向代理的，若你的服务器不是，则可以跳过此内容。<strong>若你完全不了解 nginx 建议先去学习了之后再回来进行配置，因为此处我写得很简略，可能会对你产生误导。</strong></p>
<p>我的 Nginx 代理了80端口，所有的请求都是从此处进入上文提到，需要从 8111 端口进入才能访问内网，所以我需要对 nginx 添加一些配置：</p>
<p><img src="https://s2.loli.net/2023/08/27/RrNxIVbkSTgGQOy.png" alt="2023-08-17_15-48.png" /></p>
<p>这样，当请求 bitwarden 路径时，将会反向代理到 8111 端口</p>
<p>当然，通过 nginx 也可以配置子域名来访问，首先将三级域名 bitwarden.yarnom.top 通过 CNAME 指向当前的服务器地址</p>
<p>然后，nginx 设置一个新的 server ，server_name 就是这个三级域名：</p>
<p><img src="https://s2.loli.net/2023/08/27/DjX7LebSQftPovT.png" alt="2023-08-17_15-26.png" /></p>
<h2>搭建 <strong><a href="https://github.com/dani-garcia/vaultwarden">Vaultwarden</a></strong></h2>
<p>由于官方的 Bitwarden 服务对于我的小机子来说过于庞大了，所以选择了社区用 Rust 编写 Vaultwarden 项目</p>
<p>它可以用 docker 搭建，那就是几条命令就能安装完毕：</p>
<pre><code>Pull the docker image and mount a volume from the host for persistent storage:

docker pull vaultwarden/server:latest
docker run -d --name vaultwarden -v /vw-data/:/data/ --restart unless-stopped -p 80:80 vaultwarden/server:latest
</code></pre>
<p>完成！</p>
<h3>搭建 <a href="https://github.com/usememos/memos">Memos</a></h3>
<p>docker 搭建</p>
<pre><code>docker run -d --name memos -p 5230:5230 -v ~/.memos/:/var/opt/memos ghcr.io/usememos/memos:latest
</code></pre>
<p>自行修改参数即可。</p>
<p>完成！</p>
</div>
                <div class="tags_post"></div>
            </div>
        </div>
    
        <div class="articles">
            <div class="post">
                <div class="header_post">
                    <div class="title_post"><a href="&#x2F;posts&#x2F;七月与八月-2023-08-08 22:51:43.html">七月与八月</a></div>
                    <div class="detail_post">
                        <div class="date">发布时间：2023-08-08 22:51:43</div>
                        <div class="categories">
                            归档分类：
                            <ul>
                                
                                <li><a href="/categories/default">default</a></li>
                                
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="content_post"><p>七月就这样过去了呢，很久没有写博文了，主要是生活现在千篇一律，没啥想写的内容，总不能写一大堆的流水账不是嘛。</p>
<p>虽说是千篇一律，但最近也是有好好用功的。最近在捣鼓一个新的项目：用 Rust 语言完成静态博客生成器。我目前使用的 Hexo 就是这样的工具，它将markdown文件转换为html文件，再对 tags 和 categories 等内容进行整理。这是之前未曾接触过的代码经历。</p>
<p>事实上，一开始为真的无从下手，于是我开始询问 ChatGPT，这真是一个很棒的人工智能，它认真地回答了我很多的问题，给予了我很多实际地代码。我用了一天时间了解了 rust 的语法，囫囵吞枣地学习显然不足以支撑我完成这个项目，但是有了 ChatGPT 的帮助，事情真的变得容易了很多，之后完成了这个项目，我会写一篇更详细的文章来介绍这一过程。</p>
</div>
                <div class="tags_post"></div>
            </div>
        </div>
    
        <div class="articles">
            <div class="post">
                <div class="header_post">
                    <div class="title_post"><a href="&#x2F;posts&#x2F;🎉 评论区功能上线-2023-06-14 17:29:46.html">🎉 评论区功能上线</a></div>
                    <div class="detail_post">
                        <div class="date">发布时间：2023-06-14 17:29:46</div>
                        <div class="categories">
                            归档分类：
                            <ul>
                                
                                <li><a href="/categories/网站维护">网站维护</a></li>
                                
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="content_post"><p>今天上线了友链，于是寻思着把评论区也添加上，使用的是 <a href="https://giscus.app/zh-CN">giscus</a> ，这是利用 <a href="https://docs.github.com/en/discussions">GitHub Discussions</a> 实现的评论系统。</p>
</div>
                <div class="tags_post"></div>
            </div>
        </div>
    
        <div class="articles">
            <div class="post">
                <div class="header_post">
                    <div class="title_post"><a href="&#x2F;posts&#x2F;🎉 友链功能上线-2023-06-14 16:03:31.html">🎉 友链功能上线</a></div>
                    <div class="detail_post">
                        <div class="date">发布时间：2023-06-14 16:03:31</div>
                        <div class="categories">
                            归档分类：
                            <ul>
                                
                                <li><a href="/categories/网站维护">网站维护</a></li>
                                
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="content_post"><p>今日和朋友闲聊，话题扯到了我们各自的博客上，我周围写博客的人还是蛮少的，很高兴他也一直在写博客，于是我们便萌生了交换友链的想法。</p>
<p>但问题在于，我的博客并没有这个功能，但是 Hexo 完成这个功能也简单，这也是静态博客的一大优势，代码的实现非常简单。</p>
<p>于是在经过了两分钟的编程后，我正式宣布我的博客友链功能正式上线 ！！！🎉🎉🎉</p>
</div>
                <div class="tags_post"></div>
            </div>
        </div>
    
    <div class="paginator">
    
        <a href=".&#x2F;" class="extend prev">上一页</a>
    
        <a href="" class="page_number current">1</a>
          
        <a href="&#x2F;page&#x2F;2" class="extend next">下一页</a>
    

</div>

        </div>
    </div>

    
</body>
<footer>
    <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/">CC BY-NC-ND 4.0</a>
</footer> 
</html>