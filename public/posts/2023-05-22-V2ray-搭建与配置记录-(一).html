<!DOCTYPE html>
<html>
<head>

    <meta charset="UTF-8">
    <title>2023-05-22-V2ray-搭建与配置记录-(一)</title>
    <link rel="stylesheet" href="../static/css/style.css">
</head>
<body>
    <h1>V2ray 搭建与配置记录 (一)</h1>
    <h3>2023-05-22 12:34:43</h3>
    <h2>前言</h2>
<p>近来想纯净自己的ip，同时也想试着搭建 v2ray 服务供以自己代理使用，所以上两个星期便购买了一台 Vultr 的 VPS。出现了一些问题，同时也确实都得以解决了，想着这里简单记录一下配置的过程，以便下次继续搭建。</p>
<p>这是第一次尝试使用 vps 搭建 v2ray 服务，事实上非常的顺利，我确实完成了 v2ray 的搭建，但是第三天便遭到了中国政府的防火墙一记 ban ip 操作。现在想着这是极为危险的，但事情还得继续，问题自然是发生在我未对 v2ray 进行伪装，因为初次接触，所以对很多新的名词有恐惧心理，一开始便没有去尝试伪装操作，最终酿下错误，但是错误的本身其实也在推动着我技术的进步。</p>
<p>问题的解决方法是，首先通过 WebSocket+TLS+Web 完成对传输层流量伪装，原理就是通过 Nginx 搭建了一个真实的网站，分流一个特定的路由去转发 v2ray 的流量，其实正常的伪装到这里就结束了。但前面我说了，我的 VPS ip 被封杀了，其导致了我没办法在国内正常通过 ssh 访问到服务器，所以根据攻略我又加了一层伪装，我将我的域名名服务器交给 cloudflare 让其帮我把域名伪装成其他的ip，从而躲过封杀。</p>
<p>目前时间是 2023年5月，之前的文章都没有强调要一定套上 TLS 伪装才能使用，但事实上，随着时间的发展，直接使用 v2ray 已经能被精确发现，套一上 TLS ，加密 HTTP 是很有必要的。</p>
<h2>配置 vps 和 v2ray</h2>
<p>请注意，在接下来的所有操作中，我均使用 root 账户执行操作。</p>
<h3>安装 git</h3>
<pre><code>apt-get install git
</code></pre>
<h3>安装 zsh 和 ohmyzsh</h3>
<p>Linux 自带的 bash 不是那么方便使用，所以换成 zsh 是个更好的选择。</p>
<pre><code>apt-get install zsh
sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;
</code></pre>
<h3>安装 v2ray</h3>
<h4>通过官方脚本自动安装 v2ray 本体</h4>
<p>确实有很多种方式安装 v2ray，我这里选择使用 <code>fhs-install-v2ray</code> 项目提供的安装脚本进行安装：
主要是它能帮我自动创建一些文件：</p>
<pre><code>installed: /usr/local/bin/v2ray
installed: /usr/local/bin/v2ctl
installed: /usr/local/share/v2ray/geoip.dat
installed: /usr/local/share/v2ray/geosite.dat
installed: /usr/local/etc/v2ray/config.json
installed: /var/log/v2ray/
installed: /var/log/v2ray/access.log
installed: /var/log/v2ray/error.log
installed: /etc/systemd/system/v2ray.service
installed: /etc/systemd/system/v2ray@.service
</code></pre>
<p>执行下面的程序脚本即可（目前时间是：2023-05-22，该脚本未来可能发生变动，以具体情况为准）
此处贴出项目 README 文件：<a href="https://github.com/v2fly/fhs-install-v2ray/blob/master/README.zh-Hans-CN.md">README.zh</a></p>
<pre><code>bash &lt;(curl -L https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh)
</code></pre>
<p>执行完后，若无明显错误，即可通过 <code>systemctl start v2ray.service</code> 和 <code>systemctl status v2ray.service</code> 查看是否能正确启动。</p>
<h4>配置 v2ray 服务端</h4>
<p>无论是服务端亦或是客户端的配置，其实都非常简单，只需要将配置文件改动一些即可使用。
以下是官方提供的服务端配置：</p>
<pre><code class="language-json">{
    &quot;inbounds&quot;: [
        {
            &quot;port&quot;: 11223, // 服务器监听端口
            &quot;protocol&quot;: &quot;vmess&quot;,
            &quot;settings&quot;: {
                &quot;clients&quot;: [
                    {
                        &quot;id&quot;: &quot;xxxxxxxxxxxxxxx&quot;,
                        &quot;alterId&quot;: 0
                    }
                ]
            }
        }
    ],
    &quot;outbounds&quot;: [
        {
            &quot;protocol&quot;: &quot;freedom&quot;
        }
    ]
}
</code></pre>
<p>在入门阶段，只需要了解 <code>inbounds</code> 中的 <code>port</code> 和 <code>id</code> 即可。</p>
<ul>
<li><code>port</code> 即是服务器的监听端口</li>
<li><code>id</code> 可以理解为某种密钥一样的存在，在服务端与客户端交流时，需要通过这值进行辨别身份。可以使用 <code>cat /proc/sys/kernel/random/uuid</code> 指令生成这个 id。</li>
</ul>
<blockquote>
<p>服务器的配置中需要确保 id 和端口与客户端一致，就可以正常连接了。</p>
</blockquote>
<p>最后重启一下 v2ray 服务即可：<code>systemctl restart v2ray.service</code> ，当然因为可能存在的将配置文件写错的问题，最好再查看一下有没有错误产生 <code>systemctl status v2ray.service</code></p>
<p>没有问题后，即可开始配置 v2ray 客户端。</p>
<p>啊，最后注意让防火墙放开对应的端口，比如这里的11223端口，若是不开放是万万无法连接的</p>
<pre><code>ufw allow 11223/tcp
</code></pre>
<h3>配置 v2ray 客户端</h3>
<ul>
<li>Linux 平台可以使用 v2ray 程序(服务器所用的那个)，它即可以当服务端也可以作为客户端使用</li>
<li>Android 平台可以使用 v2rayNG</li>
<li>Windows 平台可以使用 v2rayN</li>
</ul>
<p>无论是 android 还是 windows，其都有相应的图形界面，配置起来很简单，这里主要讲一下 Linux 的 v2ray 如何作为客户端使用。</p>
<p>v2ray 既可以作为服务端也可以作为客户端，只不过是配置不同而已。</p>
<p>以下贴出官方提供的客户端配置：</p>
<pre><code class="language-json">{
  &quot;inbounds&quot;: [
    {
      &quot;port&quot;: 1080, // 监听端口
      &quot;protocol&quot;: &quot;socks&quot;, // 入口协议为 SOCKS 5
      &quot;sniffing&quot;: {
        &quot;enabled&quot;: true,
        &quot;destOverride&quot;: [&quot;http&quot;, &quot;tls&quot;]
      },
      &quot;settings&quot;: {
        &quot;auth&quot;: &quot;noauth&quot;  //socks的认证设置，noauth 代表不认证，由于 socks 通常在客户端使用，所以这里不认证
      }
    }
  ],
  &quot;outbounds&quot;: [
    {
      &quot;protocol&quot;: &quot;vmess&quot;, // 出口协议
      &quot;settings&quot;: {
        &quot;vnext&quot;: [
          {
            &quot;address&quot;: &quot;serveraddr.com&quot;, // 服务器地址，请修改为你自己的服务器 IP 或域名
            &quot;port&quot;: 16823,  // 服务器端口
            &quot;users&quot;: [
              {
                &quot;id&quot;: &quot;xxxxxx&quot;,  // 用户 ID，必须与服务器端配置相同
                &quot;alterId&quot;: 0 // 此处的值也应当与服务器相同
              }
            ]
          }
        ]
      }
    }
  ]
}
</code></pre>
<p>虽然这看起来蛮多的，但需要修改的地方也就是 <code>outbounds</code> 里的 <code>address</code>、<code>port</code> 和 <code>id</code></p>
<ul>
<li><code>address</code> 填入 vps 的 ip 地址亦或是域名</li>
<li><code>port</code> 填入服务端中监听的那个地址</li>
<li><code>id</code> 填入服务端设定的 id</li>
</ul>
<p>这样一切弄完后，在配置一下 <code>socks_proxy</code> 的环境变量即可。</p>
<pre><code>export socks_proxy=https://127.0.0.1:1080;&quot;
</code></pre>
<p>当然也可以把 <code>http_proxy</code> 和 <code>https_proxy</code> 代理填入。</p>
<p>若是你想在浏览器使用：</p>
<ul>
<li>firefox 相对方便，直接在设置中选择 socks5 代理，地址即填入配置文件中的：<code>127.0.0.1:1080</code></li>
<li>chrome 可以去下载 名为 <code>SwitchyOmega</code> 的插件，也使用 sock5 配置即可</li>
</ul>
<p>好啦，到目前为止，服务端和客户端都已经配置完成。</p>
<h3>TLS 加密前言</h3>
<p>接下来有一些太长的内容，若是你不感兴趣，则可以跳过。</p>
<p>此处先给出参考的文章引用，在文章末尾也会重复给出，感谢各位前辈的教程。</p>
<ul>
<li><a href="https://www.v2fly.org/guide/install.html">V2Fly</a></li>
<li><a href="https://whuwangyong.vercel.app/2023-03-18-v2ray-websocket-tls-web-cloudflare-guide/">V2Ray+WebSocket+TLS+Web+Cloudflare教程</a></li>
<li><a href="https://linuxfunk.com/2017/10/31/v2ray-ws-tls-nginx%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93/">linuxfunk</a></li>
<li><a href="https://cyfeng.science/2020/03/22/advanced-v2ray-with-wss/">V2Ray进阶指南：WSS组合配置(WebSocket + TLS + Nginx + CDN)</a></li>
</ul>
<p>在完成了之前那些操作后，自然是可以正常使用 v2ray 的，但是非常容易被封杀(我的坚持了两天hhhhh)，这也是我后来才得知道的 :(</p>
<p>总之，被封杀了我便意识到了伪装是极其重要的，以下先介绍一些概念名称，我刚开始接触这一部分便直接放弃了，但遗憾的是这一部分却又不得不学，我们只能被迫去与之对抗。</p>
<h4>TLS</h4>
<p><code>TLS 加密</code>，TLS 中文叫 传输层安全性协议，以下是 wikipedia 的描述：</p>
<blockquote>
<p>将通信两方交换的资料做加密，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听</p>
</blockquote>
<p>这是用来加密的，广为人知的 <code>HTTP</code> 在经过 TLS 加密后，成为了<code>HTTPS</code></p>
<p>若是 v2ray 的流量没有被 TLS 加密，那么审查者便能根据数据内容分析出，这是违“法”的数据，而且代理流量源源不断地从固定 ip 发来，这样的流量同样是不正常的。</p>
<h4>网站前置伪装 与 websocket 协议</h4>
<p>仅用 TLS 加密依旧是不够的，因为流量不正常，这些大规模的流量因为代理的原因来去于同一个ip，这样的流量即使是加密的，也应该是有问题的。所以，需要再完成一次伪装，使用 Nginx 与 域名 搭建一个真实的网站，我们的客户端通过 websocket（ws）协议与这个用 Nginx 作为前端的网站进行数据交流，这样一来，我们的服务器就是正儿八经的网站服务器（事实也确实如此），而非代理服务器，在找到某种特征之前，不可能大面积封杀这样的正常服务器。</p>
<p>使用，我们现在的任务很简单，购买一个域名（可以是免费的二级域名），在我们的 VPS 中通过 Nginx 搭建一个真实但简单的网站，然后让客户端和服务器端通过ws协议交流，接着通过 Nginx 分流特定的路由。</p>
<h2>V2Ray + TLS + Websocket</h2>
<p><strong>若是你需要使用 TLS 加密你的流量，则你必须拥有一个域名！</strong></p>
<p><strong>本文 使用 domain.com  作为演示。</strong></p>
<h3>域名购买</h3>
<ol>
<li>namesilo 购买</li>
<li>eu.org 申请二级域名</li>
</ol>
<p>这里完全不推荐在国内购买相关域名，备案审查总归是非常麻烦且不安全。我的域名都是在 namesilo 进行购买，它支持使用支付宝，在国内来说是相对方便的，购买后可以选择使用cloudflare 的 cdn，若是选择了cloudflare 托管名服务器，在国内而已速度是会降低很多的（但是可以接受）。</p>
<p>而接下来介绍的第二种方法则完全依靠于 cloudflare 的 tls ，完成 https 的证书一键生成，可以免去大量地繁琐操作。</p>
<p>若是你不希望花费金钱，你可以从 <strong>EU.org</strong> 申请一个二级域名，之后将这个二级域名交付 cloudflare 管理，同样能完成 TLS 加密。</p>
<p>在购买了域名之后，使用 A 记录指向服务器 ip 即可。</p>
<h3>起步之前的话</h3>
<p>在之前的操作中，我们在服务器中使用 v2ray 监听了 11223 端口，同时开放了防火墙，但若你要进行接下来的操作，记得之后关闭这个端口，因为最终我们会使用 nginx 对流量进行分流，也就是反向代理，便不需要这个端口了。</p>
<h3>方法一</h3>
<p>首先说明，这是一个比较费时费力的方法，需要一些 Linux 和 Web 的相关知识，但这是相对普遍的方法。</p>
<p>其过程如下：</p>
<ul>
<li>部署一个页面或者网站，即使很简单也没有问题</li>
<li>给网站安装 tls 证书</li>
<li>使用 Nginx 完成反向代理</li>
</ul>
<h4>部署一个页面或者网站</h4>
<h5>建立站点根目录</h5>
<p>我们在 <code>/var/www</code> 新建一个目录：</p>
<pre><code>$ mkdir domain.com
$ cd domain.com
$ vim index.html
</code></pre>
<p>对于 <code>index.html</code> 随便写些内容就好，比如：</p>
<pre><code> &lt;h1&gt; Hello World &lt;/h1&gt;
</code></pre>
<h5>修改 nginx virtual host</h5>
<pre><code>$ cd /etc/nginx/sites-enabled
$ vim domain.com
</code></pre>
<p>内容如下：</p>
<pre><code>server {
    listen 80; # 监听80端口
    server_name domain.com; # 你的域名

    root /var/www/domain.com; # 网站根目录
    index index.html; # 主页

    # 路由
    location / {
        try_files $uri $uri/ =404;
	}
}
</code></pre>
<p>修改完后，将其作为默认的配置：</p>
<pre><code>$ ln -s domain.com default
</code></pre>
<h4>给网站安装 TLS 证书</h4>
<p>我主要是根据<a href="https://guide.v2fly.org/advanced/tls.html#%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D">这篇文章</a>完成的，建议您在操作的时作为参考使用。</p>
<h5>安装 acme.sh</h5>
<p>通过 acme.sh 脚本帮助我们完成 TLS 证书认证。</p>
<blockquote>
<p>证书有两种，一种是 ECC 证书（内置公钥是 ECDSA 公钥），一种是 RSA 证书（内置 RSA 公钥）。简单来说，同等长度 ECC 比 RSA 更安全,也就是说在具有同样安全性的情况下，ECC 的密钥长度比 RSA 短得多（加密解密会更快）。但问题是 ECC 的兼容性会差一些，Android 4.x 以下和 Windows XP 不支持。只要您的设备不是非常老的老古董，建议使用 ECC 证书。</p>
<p>来源于：<a href="https://guide.v2fly.org/advanced/tls.html#%E6%B3%A8%E5%86%8C%E4%B8%80%E4%B8%AA%E5%9F%9F%E5%90%8D">v2fly</a></p>
</blockquote>
<p>执行下面的命令，会在当前目录中创建 .acme 文件夹：</p>
<pre><code>$ curl  https://get.acme.sh | sh
</code></pre>
<p>若是出现缺少依赖，按照其给出的包名，使用<code>apt install xxxx </code>进行安装即可。</p>
<h5>证书生成</h5>
<pre><code>$ ~/.acme.sh/acme.sh --issue -d domain.com --standalone --keylength ec-256 --force
</code></pre>
<p>当然，第一次执行可能会报错，因为它需要填写电子邮箱：</p>
<pre><code>$ ~/.acme.sh/acme.sh --register-account -m xxxx@xxxx.com
</code></pre>
<p>填写完邮箱后，再重新执行第一条指令即可。</p>
<p>成功后，会打印出相关证书，在末尾则会出现，类似的内容：</p>
<pre><code>Your cert is in  /root/.acme.sh/domain.com_ecc/mydomain.me.cer
Your cert key is in  /root/.acme.sh/domain.com_ecc/mydomain.me.key
The intermediate CA cert is in  /root/.acme.sh/domain.com_ecc/ca.cer
And the full chain certs is there:  /root/.acme.sh/domain.com_ecc/fullchain.cer
</code></pre>
<blockquote>
<p>注意, 默认生成的证书都放在安装目录下: <code>~/.acme.sh/</code>, 请不要直接使用此目录下的文件, 例如: 不要直接让 nginx/apache 的配置文件使用这下面的文件. 这里面的文件都是内部使用, 而且目录结构可能会变化.</p>
<p>来源： <a href="https://github.com/acmesh-official/acme.sh/wiki/%E8%AF%B4%E6%98%8E">acmesh</a></p>
</blockquote>
<p>以下是 acme.sh README 给出的示例，使用<code> --install-cert</code>参数将证书安装到指定的位置：</p>
<pre><code>acme.sh --install-cert -d example.com \
--key-file       /path/to/keyfile/in/nginx/key.pem  \
--fullchain-file /path/to/fullchain/nginx/cert.pem \
--reloadcmd     &quot;service nginx force-reload&quot;
</code></pre>
<p>例如：</p>
<pre><code>$ ~/.acme.sh/acme.sh --install-cert -d domian.com \
	--key-file /etc/ssl/key.key	\
	--fullchain-file /etc/ssl/cert.crt
</code></pre>
<p>接下来继续配置 Nginx ，给 Nginx 安装证书，这里我手动填写了一些配置，我会一步一步完成，请耐心看下去：</p>
<p>首先，您必须得知道 HTTP 默认在 80 端口，而 HTTPS 默认在 443 端口，也就是当用户在浏览器访问类似链接时：http://domain.com,其默认从 80 端口访问的HTTP服务，这是不安全的，所以我们需要返回 301 状态码，让浏览器跳转到加密的 HTTPS 服务上来，通过 tls 加密后的链接是这样的：https://domain.com。</p>
<p>我们接下来完成的就是将访问 80 端口的流量重定位到 443端口去。</p>
<p>当然，你也可以直接跳到最后。</p>
<p>若是你一步步跟随我，你的 nginx 的配置文件应该是这样的：</p>
<pre><code>server {
    listen 80; # 监听80端口
    server_name domain.com; # 你的域名

    root /var/www/domain.com; # 网站根目录
    index index.html; # 主页

    # 路由
    location / {
        try_files $uri $uri/ =404;
	}
}
</code></pre>
<p>我们对其进行一些修改，依旧是监听 80 端口，这是 HTTP 协议默认端口，但是这是不安全的，我们之前已经配置了 TLS，接下来需要做的技术凡是从80进入的流量全部转发至 433 端口，这是加密的 HTTPS 默认的端口。</p>
<p>也就是，当用户浏览器从 http://mydomain.com 进入时，将其跳转至 https://mydomain.com.</p>
<pre><code>server {
	listen 80; # 监听80端口，将所有访问 80 端口的流量，全部重定位到 https
	server_name domain.com;

	# 301 重定位
	if ($host = mydomain.com) {
		return 301 https://$host$request_uri;
 	}
	# 否则返回 404
	return 404;
}
</code></pre>
<p>接着，我们具体配置一下 来自 443 端口的流量，在上一步后，所有使用 http 协议的请求均会被重定位到 443 端口。</p>
<p>下面的文件添加了新的 server , 它将监听443端口，同时我们部署了证书文件通过 <code>ssl_certificate</code> 和 <code>ssl_certificate_key </code></p>
<pre><code>server {
	listen 443 ssl; # 监听443端口
	server_name domain.com;
	root /var/www/mydomain.com;
 	index index.html;

	ssl_certificate       /etc/ssl/cert.crt;
	ssl_certificate_key   /etc/ssl/key.key;
	ssl_session_timeout 1d;
	ssl_session_cache shared:MozSSL:10m;
	ssl_session_tickets off;
	ssl_protocols         TLSv1.2 TLSv1.3;

 	location / {
		try_files $uri $uri/ =404;
	}


}

server {
	listen 80; # 监听80端口，将所有访问 80 端口的流量，全部重定位到 https
	server_name domain.com;

	# 301 重定位
	if ($host = mydomain.com) {
		return 301 https://$host$request_uri;
 	}
	# 否则返回 404
	return 404;
}
</code></pre>
<p>在份文件中，我新增了：</p>
<pre><code>server {
	listen 443 ssl; # 监听443端口
	server_name domain.com;
	root /var/www/mydomain.com;
 	index index.html;

	ssl_certificate       /etc/ssl/cert.crt;
	ssl_certificate_key   /etc/ssl/key.key;
	ssl_session_timeout 1d;
	ssl_session_cache shared:MozSSL:10m;
	ssl_session_tickets off;
	ssl_protocols         TLSv1.2 TLSv1.3;

 	location / {
		try_files $uri $uri/ =404;
	}


}
</code></pre>
<p>上面这一步，则是在处理 443 端口发来的请求的路由情况，我们任然是当其 进入<code>/</code> 后，返回当前网站的根目录。</p>
<p>接着，我们来处理 V2ray 的流量，我们设定一个路由 <code>/proxy</code>，凡是进入该路由的，均将流量反向代理至 v2ray 监听的端口，之前设置的是 11223。</p>
<pre><code>server {
	listen 443 ssl; # 监听443端口
	server_name domain.com;
	root /var/www/mydomain.com;
 	index index.html;

	ssl_certificate       /etc/ssl/cert.crt;
	ssl_certificate_key   /etc/ssl/key.key;
	ssl_session_timeout 1d;
	ssl_session_cache shared:MozSSL:10m;
	ssl_session_tickets off;
	ssl_protocols         TLSv1.2 TLSv1.3;

 	location / {
		try_files $uri $uri/ =404;
	}

	location /proxy {
	# WebSocket协商失败时返回404
    if ($http_upgrade != &quot;websocket&quot;) {
        return 404;
    }
    proxy_redirect off;
    proxy_pass http://127.0.0.1:11223; # 转发至 11223 端口，v2ray监听处
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection &quot;upgrade&quot;;
    proxy_set_header Host $host;
    # Show real IP in v2ray access.log
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }


}

server {
	listen 80; # 监听80端口，将所有访问 80 端口的流量，全部重定位到 https
	server_name domain.com;

	# 301 重定位
	if ($host = mydomain.com) {
		return 301 https://$host$request_uri;
 	}
	# 否则返回 404
	return 404;
}
</code></pre>
<p>可以看到，这份文件中，我新增了:</p>
<pre><code>location /proxy {
	# WebSocket协商失败时返回404
    if ($http_upgrade != &quot;websocket&quot;) {
        return 404;
    }
    proxy_redirect off;
    proxy_pass http://127.0.0.1:11223; # 转发至 11223 端口，v2ray监听处
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection &quot;upgrade&quot;;
    proxy_set_header Host $host;
    # Show real IP in v2ray access.log
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  }
</code></pre>
<p>它将 从 /proxy 路由进入的流量反向代理至 11223 端口</p>
<p>那么，Nginx 的配置就完成啦！！！</p>
<p>上面这份就是最终的配置文件。</p>
<h4>V2ray 服务端配置</h4>
<p><em><strong>原先：</strong></em></p>
<pre><code>{
    &quot;inbounds&quot;: [
        {
            &quot;port&quot;: 11223, // 服务器监听端口
            &quot;protocol&quot;: &quot;vmess&quot;,
            &quot;settings&quot;: {
                &quot;clients&quot;: [
                    {
                        &quot;id&quot;: &quot;xxxxxxxxxxxxxxx&quot;,
                        &quot;alterId&quot;: 0
                    }
                ]
            }
        }
    ],
    &quot;outbounds&quot;: [
        {
            &quot;protocol&quot;: &quot;freedom&quot;
        }
    ]
}
</code></pre>
<p>在 <code>inbounds</code>添加<code>streamSettings</code>设置：</p>
<pre><code>{
    &quot;inbounds&quot;: [
        {
            &quot;port&quot;: 11223,
            &quot;listen&quot;: &quot;127.0.0.1&quot;,
            &quot;protocol&quot;: &quot;vmess&quot;,
            &quot;settings&quot;: {
                &quot;clients&quot;: [
                    {
                        &quot;id&quot;: &quot;xxxxxx&quot;,
                        &quot;alterId&quot;: 0
                    }
                ]
            },
            &quot;streamSettings&quot;: {
                &quot;network&quot;: &quot;ws&quot;,
                &quot;wsSettings&quot;: {
                    &quot;path&quot;: &quot;/proxy&quot;
                }
            }
        }
    ],
    &quot;outbounds&quot;: [
        {
            &quot;protocol&quot;: &quot;freedom&quot;,
            &quot;settings&quot;: {}
        }
    ]
}
</code></pre>
<p>恭喜你，在你完成这一步，在服务端所要干的事情就完成了！</p>
<h4>V2ray 客户端配置</h4>
<p>客户端就没啥好说的了，就是基本配置一下即可。</p>
<p>主要修改的地方就是 <code>outbounds</code> 的 <code>address</code> 和 <code>streamSettings</code></p>
<pre><code>{
  &quot;inbounds&quot;: [
    {
      &quot;port&quot;: 1080,
      &quot;protocol&quot;: &quot;socks&quot;,
      &quot;sniffing&quot;: {
        &quot;enabled&quot;: true,
        &quot;destOverride&quot;: [&quot;http&quot;, &quot;tls&quot;]
      },
      &quot;settings&quot;: {
        &quot;auth&quot;: &quot;noauth&quot;
      }
    }
  ],
  &quot;outbounds&quot;: [
    {
      &quot;tag&quot;:&quot;default&quot;,
      &quot;protocol&quot;: &quot;vmess&quot;,
      &quot;settings&quot;: {
        &quot;vnext&quot;: [
          {
            &quot;address&quot;: &quot;domain.com&quot;,
            &quot;port&quot;: 443,
            &quot;users&quot;: [
              {
                &quot;id&quot;: &quot;xxxxx&quot;,
                &quot;alterId&quot;: 0
              }
            ]
          }
        ]
      },
      &quot;streamSettings&quot;:{
      	&quot;network&quot;: &quot;ws&quot;,
		&quot;security&quot;: &quot;tls&quot;,
		&quot;wsSettings&quot;: {
	  		&quot;path&quot;:&quot;/proxy&quot;
		}
      }
    }
  ]
}
</code></pre>
<h2>最后及参考</h2>
<p>只有果壳中走出，才知道自由是何物。</p>
<ul>
<li><a href="https://www.v2fly.org/guide/install.html">V2Fly</a></li>
<li><a href="https://whuwangyong.vercel.app/2023-03-18-v2ray-websocket-tls-web-cloudflare-guide/">V2Ray+WebSocket+TLS+Web+Cloudflare教程</a></li>
<li><a href="https://linuxfunk.com/2017/10/31/v2ray-ws-tls-nginx%E5%AE%9E%E7%8E%B0%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93/">linuxfunk</a></li>
<li><a href="https://cyfeng.science/2020/03/22/advanced-v2ray-with-wss/">V2Ray进阶指南：WSS组合配置(WebSocket + TLS + Nginx + CDN)</a></li>
</ul>

</body>
</html>